{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home A modern, powerful, experimental, and modular Discord bot framework Installation Note: You must be logged into the GitHub package registry before this will work. To install Blueprint you first need to configure NPM to use the GitHub package registry, to do this first create a .npmrc file with the following contents, after you can install the library using npm i @xpyxel/blueprint . @xpyxel:registry=https://npm.pkg.github.com Official Support If you need help with contributing to the library or using it, you can join our official Discord server . You will be able to chat with other people that use or contribute to the library, as well talk to the maintainers directly. Do note that we (the maintainers) do not provide 1-on-1 support for the library.","title":"Home"},{"location":"#home","text":"A modern, powerful, experimental, and modular Discord bot framework","title":"Home"},{"location":"#installation","text":"Note: You must be logged into the GitHub package registry before this will work. To install Blueprint you first need to configure NPM to use the GitHub package registry, to do this first create a .npmrc file with the following contents, after you can install the library using npm i @xpyxel/blueprint . @xpyxel:registry=https://npm.pkg.github.com","title":"Installation"},{"location":"#official-support","text":"If you need help with contributing to the library or using it, you can join our official Discord server . You will be able to chat with other people that use or contribute to the library, as well talk to the maintainers directly. Do note that we (the maintainers) do not provide 1-on-1 support for the library.","title":"Official Support"},{"location":"commands/","text":"Commands For commands Blueprint uses a decorator and a abstract class, the two combined make a sleek, readable, and modern format for definining commands using the framework. Commands are also grouped together using a very basic \"plugin\" system. This allows groups of commands to be disabled and enabled en masse, this is useful if you have developer commands that you only want to be enabled in a development environment, as you can disable the entire group in production. The Command Decorator The @Command() decorator is used to apply command metadata to a class, this is usually coupled with the Executor abstract class that will be discussed later on this part of the documentation. The decorator takes an object containing two properties, a groups array, containing a list of names of groups that you have specified earlier using the group registry , and an aliases array which contains a list of alternative names for the command. The Executor Class The Executor class enforces the function or method signature for the callback method of a command's class. This is used to ensure that when creating a command definition, that all commands follow a specific signature and therefor ensuring everything runs smoothly when passing arguments to the command's callback. Command Example As an example of what a command in blueprint would look like, here is a basic example of a ping command that returns the message lantecy calculated by the time taken to send a message in a text channel. This only shows a very small capability of what the command system is capable of. @Command({ groups: ['user'], aliases: ['latency', 'time'], }) export class PingCommand extends Executor { async callback(ctx: Message, ref: Blueprint) { const startTime = Date.now(); const msg = await ctx.channel.createMessage('Getting response time'); msg.edit(`Response time is \\`${Date.now() - startTime}\\``); } } Grouping Commands Plugins are the very simple way Blueprint groups commands together. They are at their simpliest form a registry with a few extra methods to handle command execution within them. Creating plugins is extremely simple, and only required basic JavaScript knowledge of knowing how to create class instances using the new keyword. Creating plugins To create a plugin, you simply need to instantiate a new instance of the Plugin class. const pluginName = new Plugin(); After you have instantiated a new plugin instance, you can then register commands to it. pluginName.register('commandName', new CommandClass()); Deactivating or disabling commands, is simply using pluginName.unregister() with the plugin's name. pluginName.unregister('commandName'); In order for plugins to be recognized by the framework you must register them in the plugin registry .","title":"Commands"},{"location":"commands/#commands","text":"For commands Blueprint uses a decorator and a abstract class, the two combined make a sleek, readable, and modern format for definining commands using the framework. Commands are also grouped together using a very basic \"plugin\" system. This allows groups of commands to be disabled and enabled en masse, this is useful if you have developer commands that you only want to be enabled in a development environment, as you can disable the entire group in production.","title":"Commands"},{"location":"commands/#the-command-decorator","text":"The @Command() decorator is used to apply command metadata to a class, this is usually coupled with the Executor abstract class that will be discussed later on this part of the documentation. The decorator takes an object containing two properties, a groups array, containing a list of names of groups that you have specified earlier using the group registry , and an aliases array which contains a list of alternative names for the command.","title":"The Command Decorator"},{"location":"commands/#the-executor-class","text":"The Executor class enforces the function or method signature for the callback method of a command's class. This is used to ensure that when creating a command definition, that all commands follow a specific signature and therefor ensuring everything runs smoothly when passing arguments to the command's callback.","title":"The Executor Class"},{"location":"commands/#command-example","text":"As an example of what a command in blueprint would look like, here is a basic example of a ping command that returns the message lantecy calculated by the time taken to send a message in a text channel. This only shows a very small capability of what the command system is capable of. @Command({ groups: ['user'], aliases: ['latency', 'time'], }) export class PingCommand extends Executor { async callback(ctx: Message, ref: Blueprint) { const startTime = Date.now(); const msg = await ctx.channel.createMessage('Getting response time'); msg.edit(`Response time is \\`${Date.now() - startTime}\\``); } }","title":"Command Example"},{"location":"commands/#grouping-commands","text":"Plugins are the very simple way Blueprint groups commands together. They are at their simpliest form a registry with a few extra methods to handle command execution within them. Creating plugins is extremely simple, and only required basic JavaScript knowledge of knowing how to create class instances using the new keyword.","title":"Grouping Commands"},{"location":"commands/#creating-plugins","text":"To create a plugin, you simply need to instantiate a new instance of the Plugin class. const pluginName = new Plugin(); After you have instantiated a new plugin instance, you can then register commands to it. pluginName.register('commandName', new CommandClass()); Deactivating or disabling commands, is simply using pluginName.unregister() with the plugin's name. pluginName.unregister('commandName'); In order for plugins to be recognized by the framework you must register them in the plugin registry .","title":"Creating plugins"},{"location":"configuration/","text":"Configuration Blueprint uses a YAML schema and format for configuring the library and bots using it. This allows a human-readable, syntatically nice looking, and easy to understand configuration. Due to the library using a yaml parser , it can inadvertently parse JSON as well, since YAML is a superset of JSON, and therefor either works. Config Sections The configuration file for Blueprint is split into 4 seperate parts, each part correleating to a specific \"module\" of the framework. The only 2 required parts of the configuration schema are the bot and developers sections. Each section of the configuration schema will be explained below, with a minimal example. Bot Settings The bot section of the configuration schema defines the settings for the bot part of the framework, this part is required and is needed to connect to Discord in general. All of the settings used in this section are passed to the core library the framework is based on ( Eris ) in order to connect and maintain a valid API client. Note: The bot.options section is optional; it is best to look at the settings here , on the Eris documentation. Bot Section Example bot: prefix: '!' token: 'example_bot_token_here' options: compress: true intents: - guilds - guildMembers - guildBans - guildMessages - guildPresences - directMessages Logging Settings The logging section of the configuration schema is optional, this is so that if people want to use a custom logger, they can completely disable the logging module by not specifying logger settings. For those who do however want to use the default logger, Blueprint's logging is based on the log4js library, which is extremely powerful and customizable, due to this we can't provide exact documentation, and instead it's recommended to read their documentation here . Logging Section Example logging: appenders: default: type: stdout categories: default: appenders: [stdout] level: debug Database Settings The database section, like the logging section previously is entirely optional, however it is recommended to use the built in database management as it is based on the amazing TypeORM library. This allows a very powerful yet easy to use ORM model for managing database(s). We will not go over how to create entities here, but will in another section. Once again, due to the sheer complexity of the configuration that can be used for the library, it is recommended to read their documentation, specifically the Connection Options page of it, as it will give you an overview of the settings. Note: You have to install the driver for your database of choice as this is not provided by default due to the sheer amount of drivers TypeORM can support, for more information on this read part 4 of the installation section on their website. Database Section Example database: type: 'sqlite' database: 'example.sqlite' synchronize: true entities: - 'build/src/entities/**/*.js' Developer List The developers section is a required part of the configuration schema, as it automatically allocates user ids to a built-in permission group called developer . The only way to obtain the developer group is to have the user's ids specified in this part of the configuration. Developer List Example developers: - '333459879379337216' - '349977940198555660' Complete Example bot: prefix: '!' token: 'example_bot_token_here' options: compress: true logging: appenders: default: type: stdout categories: default: appenders: [stdout] level: debug database: type: 'sqlite' database: 'example.sqlite' synchronize: true entities: - 'build/src/entities/**/*.js' developers: - '333459879379337216'","title":"Configuration"},{"location":"configuration/#configuration","text":"Blueprint uses a YAML schema and format for configuring the library and bots using it. This allows a human-readable, syntatically nice looking, and easy to understand configuration. Due to the library using a yaml parser , it can inadvertently parse JSON as well, since YAML is a superset of JSON, and therefor either works.","title":"Configuration"},{"location":"configuration/#config-sections","text":"The configuration file for Blueprint is split into 4 seperate parts, each part correleating to a specific \"module\" of the framework. The only 2 required parts of the configuration schema are the bot and developers sections. Each section of the configuration schema will be explained below, with a minimal example.","title":"Config Sections"},{"location":"configuration/#bot-settings","text":"The bot section of the configuration schema defines the settings for the bot part of the framework, this part is required and is needed to connect to Discord in general. All of the settings used in this section are passed to the core library the framework is based on ( Eris ) in order to connect and maintain a valid API client. Note: The bot.options section is optional; it is best to look at the settings here , on the Eris documentation.","title":"Bot Settings"},{"location":"configuration/#bot-section-example","text":"bot: prefix: '!' token: 'example_bot_token_here' options: compress: true intents: - guilds - guildMembers - guildBans - guildMessages - guildPresences - directMessages","title":"Bot Section Example"},{"location":"configuration/#logging-settings","text":"The logging section of the configuration schema is optional, this is so that if people want to use a custom logger, they can completely disable the logging module by not specifying logger settings. For those who do however want to use the default logger, Blueprint's logging is based on the log4js library, which is extremely powerful and customizable, due to this we can't provide exact documentation, and instead it's recommended to read their documentation here .","title":"Logging Settings"},{"location":"configuration/#logging-section-example","text":"logging: appenders: default: type: stdout categories: default: appenders: [stdout] level: debug","title":"Logging Section Example"},{"location":"configuration/#database-settings","text":"The database section, like the logging section previously is entirely optional, however it is recommended to use the built in database management as it is based on the amazing TypeORM library. This allows a very powerful yet easy to use ORM model for managing database(s). We will not go over how to create entities here, but will in another section. Once again, due to the sheer complexity of the configuration that can be used for the library, it is recommended to read their documentation, specifically the Connection Options page of it, as it will give you an overview of the settings. Note: You have to install the driver for your database of choice as this is not provided by default due to the sheer amount of drivers TypeORM can support, for more information on this read part 4 of the installation section on their website.","title":"Database Settings"},{"location":"configuration/#database-section-example","text":"database: type: 'sqlite' database: 'example.sqlite' synchronize: true entities: - 'build/src/entities/**/*.js'","title":"Database Section Example"},{"location":"configuration/#developer-list","text":"The developers section is a required part of the configuration schema, as it automatically allocates user ids to a built-in permission group called developer . The only way to obtain the developer group is to have the user's ids specified in this part of the configuration.","title":"Developer List"},{"location":"configuration/#developer-list-example","text":"developers: - '333459879379337216' - '349977940198555660'","title":"Developer List Example"},{"location":"configuration/#complete-example","text":"bot: prefix: '!' token: 'example_bot_token_here' options: compress: true logging: appenders: default: type: stdout categories: default: appenders: [stdout] level: debug database: type: 'sqlite' database: 'example.sqlite' synchronize: true entities: - 'build/src/entities/**/*.js' developers: - '333459879379337216'","title":"Complete Example"},{"location":"database/","text":"Database For database management Blueprint uses TypeORM . This allows developers to have a easy to use, flexible, yet powerful ORM to manage their database(s). The actual database configuration is all done from the database part of the configuration file you create when using the framework. Entities Entities are the way Blueprint and TypeORM specify and structure data. They are classes and properties specified with types and decorators. This allows TypeORM to understand the structure of data and therefor allowing you to manage your data without having to mess with raw queries and/or SQL. For more information it is recommended to read this section of the TypeORM documentation. import {TypeORM} from '@xpyxel/blueprint'; @TypeORM.Entity() export class User { @TypeORM.PrimaryGeneratedColumn() id: number; @TypeORM.Column() username: string; @TypeORM.Column() password: string; } In order to use an entity, you must first add it to the database, note that this must be done before starting the bot and incidently starting the database connection as well. database?.add(User); You can also remove an entity from the database using another method. database?.remove(User); Repositories The recommended way to handle saving/retrieving data in Blueprint is with entity repositories. There is other methods such as TypeORM's entity manager . However this method is considered messy in some ways as you edit the data from one central place and .save() it, while as with entity repositories, you create a new entity instance, and use a repository to save it instead. For more information read up on the repository api that TypeORM uses. const users = database?.repository(User); const pyxel = new User(); pyxel.username = \"pyxel\"; pyxel.password = \"hello world\"; // saving a user entity await users?.save(pyxel); // getting a user entity const user = await users?.findOne({username: \"pyxel\"}); console.log(user); For those who would rather use the EntityManager, you can get access to the EntityManager by using the Database.manager getter, as said previously however, the recommended method is to use repositories, but we won't force you to do anything. const user = database?.manager.create(User); pyxel.username = \"pyxel\"; pyxel.password = \"hello world\"; await database?.manager.save(User);","title":"Database"},{"location":"database/#database","text":"For database management Blueprint uses TypeORM . This allows developers to have a easy to use, flexible, yet powerful ORM to manage their database(s). The actual database configuration is all done from the database part of the configuration file you create when using the framework.","title":"Database"},{"location":"database/#entities","text":"Entities are the way Blueprint and TypeORM specify and structure data. They are classes and properties specified with types and decorators. This allows TypeORM to understand the structure of data and therefor allowing you to manage your data without having to mess with raw queries and/or SQL. For more information it is recommended to read this section of the TypeORM documentation. import {TypeORM} from '@xpyxel/blueprint'; @TypeORM.Entity() export class User { @TypeORM.PrimaryGeneratedColumn() id: number; @TypeORM.Column() username: string; @TypeORM.Column() password: string; } In order to use an entity, you must first add it to the database, note that this must be done before starting the bot and incidently starting the database connection as well. database?.add(User); You can also remove an entity from the database using another method. database?.remove(User);","title":"Entities"},{"location":"database/#repositories","text":"The recommended way to handle saving/retrieving data in Blueprint is with entity repositories. There is other methods such as TypeORM's entity manager . However this method is considered messy in some ways as you edit the data from one central place and .save() it, while as with entity repositories, you create a new entity instance, and use a repository to save it instead. For more information read up on the repository api that TypeORM uses. const users = database?.repository(User); const pyxel = new User(); pyxel.username = \"pyxel\"; pyxel.password = \"hello world\"; // saving a user entity await users?.save(pyxel); // getting a user entity const user = await users?.findOne({username: \"pyxel\"}); console.log(user); For those who would rather use the EntityManager, you can get access to the EntityManager by using the Database.manager getter, as said previously however, the recommended method is to use repositories, but we won't force you to do anything. const user = database?.manager.create(User); pyxel.username = \"pyxel\"; pyxel.password = \"hello world\"; await database?.manager.save(User);","title":"Repositories"},{"location":"registries/","text":"Registries For managing things like events, plugins (command groups), and permission groups Blueprint uses registries. This allows the framework to be modular, allowing developers to register (enable) and unregister (disable) parts of their bot at will. In this section you will get an overview of each of the 3 registries that the framework's client class uses, for more information on the different things they manage, check their pages. Event Registry The event registry is what you use to manage client events, due to how the registry system works you can enable and disable different events at will, this allows you to disable events using conditions, and more, allowing you to setup different \"environments\" among other things. Each event callback is given access to a reference of your client instance, allowing you to split up your code without having to worry about copy instances of things yourself. To register an event you use the EventRegistry.register() function, as seen below client.events.register(\"eventName\", async (/** args **/) => { // Do stuff with the event here }); To unregister an event you can use the EventRegistry.unregister() function client.events.unregister(\"eventName\"); Group Registry Blueprint uses a psuedo-group system for managing permissions to commands, by default the framework comes with a single built in group known as developer . As mentioned in the developers part of the config, this group is automatically populated with user ids specified in your blueprint configuration file, and can not be manually modified. To create a new permission group you can use the GroupRegistry.register() method, note that the name parameter is case sensitive , and if you enter the case wrong when specifying it when creating commands, it will not work as the group entered will \"not exist\" to the framework. client.groups.register(\"groupName\", { permissions: [], // This is a list of Permission enum values overrides: [], // This is a optional list of user and role overrides }); Unregistering existing groups is as simple as specifying their name with the GroupRegistry.unregister() method, note that the developer built-in group can not in under any circumstances be unregistered. client.groups.unregister(\"groupName\"); Plugin Registry For managing command groups, otherwise known as \"Plugins\" in Blueprint, a registry for specifically managing the registration and execution of plugins and commands is used. Plugins in themselves are registries, specifically a registry containg classes that extend an Executor class, which enforces the method signature of command callbacks. This will be explained in more detail in the commands section part of the documentation. To register a plugin it's as simple as creating a new plugin instance, and registering it with the PluginRegistry.register() method. const adminCommands = new Plugin(); client.plugins.register(\"admin\", adminCommands); For unregistering, like other registries it's as simple as using the PluginRegistry.unregister() method. client.plugins.unregister(\"admin\");","title":"Registries"},{"location":"registries/#registries","text":"For managing things like events, plugins (command groups), and permission groups Blueprint uses registries. This allows the framework to be modular, allowing developers to register (enable) and unregister (disable) parts of their bot at will. In this section you will get an overview of each of the 3 registries that the framework's client class uses, for more information on the different things they manage, check their pages.","title":"Registries"},{"location":"registries/#event-registry","text":"The event registry is what you use to manage client events, due to how the registry system works you can enable and disable different events at will, this allows you to disable events using conditions, and more, allowing you to setup different \"environments\" among other things. Each event callback is given access to a reference of your client instance, allowing you to split up your code without having to worry about copy instances of things yourself. To register an event you use the EventRegistry.register() function, as seen below client.events.register(\"eventName\", async (/** args **/) => { // Do stuff with the event here }); To unregister an event you can use the EventRegistry.unregister() function client.events.unregister(\"eventName\");","title":"Event Registry"},{"location":"registries/#group-registry","text":"Blueprint uses a psuedo-group system for managing permissions to commands, by default the framework comes with a single built in group known as developer . As mentioned in the developers part of the config, this group is automatically populated with user ids specified in your blueprint configuration file, and can not be manually modified. To create a new permission group you can use the GroupRegistry.register() method, note that the name parameter is case sensitive , and if you enter the case wrong when specifying it when creating commands, it will not work as the group entered will \"not exist\" to the framework. client.groups.register(\"groupName\", { permissions: [], // This is a list of Permission enum values overrides: [], // This is a optional list of user and role overrides }); Unregistering existing groups is as simple as specifying their name with the GroupRegistry.unregister() method, note that the developer built-in group can not in under any circumstances be unregistered. client.groups.unregister(\"groupName\");","title":"Group Registry"},{"location":"registries/#plugin-registry","text":"For managing command groups, otherwise known as \"Plugins\" in Blueprint, a registry for specifically managing the registration and execution of plugins and commands is used. Plugins in themselves are registries, specifically a registry containg classes that extend an Executor class, which enforces the method signature of command callbacks. This will be explained in more detail in the commands section part of the documentation. To register a plugin it's as simple as creating a new plugin instance, and registering it with the PluginRegistry.register() method. const adminCommands = new Plugin(); client.plugins.register(\"admin\", adminCommands); For unregistering, like other registries it's as simple as using the PluginRegistry.unregister() method. client.plugins.unregister(\"admin\");","title":"Plugin Registry"}]}